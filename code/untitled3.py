# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OccmietRJFcIzsb9iWSziv-QNDSBe5rV
"""

from typing import List, Any

import numpy as np
import matplotlib.pyplot as plt
import cv2
import scipy
from matplotlib import pyplot as plt

# Add imports if needed:
from scipy.interpolate import interp2d
from skimage import color
from tqdm import tqdm
from numpy.linalg import pinv

def warpH(im1, H, out_size):
         lab_image = cv2.cvtColor(im1, cv2.COLOR_RGB2LAB)  # LAB
         warp_im1 = np.zeros((out_size[0], out_size[1], 3), dtype="uint8")
         x_range = np.arange(0, lab_image.shape[1])
         y_range = np.arange(0, lab_image.shape[0])
         zero_val = cv2.cvtColor(np.array([0, 0, 0], dtype="uint8").reshape(1, 1, 3), cv2.COLOR_RGB2LAB)
         f = {}
         
         for idx, ch in enumerate(["L", "A", "B"]):
             z_range = lab_image[:, :, idx]
             f[ch] = interp2d(x_range, y_range, z_range, copy="False", kind='linear')
         #H_inverse = np.linalg.inv(H)
         
         for x in tqdm(range(warp_im1.shape[1])):  # x
             for y in range(warp_im1.shape[0]):  # y
                 p2 = np.array([x, y, 1]).reshape(-1, 1)  # indexs of wrap_im1
                 p1 = H @ p2
                 p1 = p1 / p1[2, 0]  # normalized the third index
                 if p1[0] > 0  and p1[1] > 0 and p1[0] < im1.shape[1] and p1[1] < im1.shape[0]:
                     for idx, ch in enumerate(["L", "A", "B"]):
                        warp_im1[y, x, idx] = int(round(f[ch](p1[0, 0], p1[1, 0])[0]))
                     continue
                 warp_im1[y, x, :] = zero_val        

         warp_im1 = cv2.cvtColor(warp_im1.astype("uint8"), cv2.COLOR_LAB2RGB)
         return warp_im1

def FindCorners(im1, H):
    # # This function used is function Translation that is used in HW function wrapH
    # H_inverse = np.linalg.inv(H)
    #
    left_top_original = np.array([0, 0, 1]).reshape(-1, 1)
    left_bottom_original = np.array([0, im1.shape[0], 1]).reshape(-1, 1)
    right_top_original = np.array([im1.shape[1], 0, 1]).reshape(-1, 1)
    right_bottom_original = np.array([im1.shape[1], im1.shape[0], 1]).reshape(-1, 1)
    #
    left_top =pinv(H) @ left_top_original
    left_bottom = pinv(H) @ left_bottom_original
    right_top =pinv(H) @ right_top_original
    right_bottom = pinv(H) @ right_bottom_original
    #
    # # normalized
    left_top /= left_top[2, :]
    left_bottom /= left_bottom[2, :]
    right_top /= right_top[2, :]
    right_bottom /= right_bottom[2, :]

    print(left_top)
    print(left_bottom)
    print(right_top)
    print(right_bottom)
    axis_top_button = [left_top, left_bottom, right_top, right_bottom]
    #
    return axis_top_button

def Translation(im1, H):
        # # This function used is in HW function wrapH
        #

        axis_top_button = FindCorners(im1, H)
        left_top = axis_top_button[0] 
        left_bottom = axis_top_button[1]
        right_top = axis_top_button[2]
        right_bottom = axis_top_button[3]
        axis_y_top = int(min(right_top[1], left_top[1]))
        axis_y_bottom = int(max(right_bottom[1], left_bottom[1]))
        axis_x_left = int(min(left_top[0], left_bottom[0]))
        axis_x_right = int(max(right_top[0], right_bottom[0]))

        print(axis_y_top)
        print(axis_y_bottom)
        print(axis_x_left)
        print(axis_x_right)

        axis_arr = [axis_y_top, axis_y_bottom, axis_x_left, axis_x_right ]
        out_size = (abs(axis_y_bottom - axis_y_top), abs((axis_x_right - axis_x_left)))
        trans_mat = np.array([[1, 0, axis_x_left], [0, 1, axis_y_top], [0, 0, 1]])
        H_trans = H @ trans_mat #h2to1
        return H_trans, out_size, axis_arr

def getScaled(im2, warp_im1, axis_arr):
        
        #
        axis_y_top = axis_arr[0]
        axis_y_bottom = axis_arr[1]
        axis_x_left = axis_arr[2]
        axis_x_right = axis_arr[3]
        #

        shape_y = max(axis_y_bottom, im2.shape[0]) - min(axis_y_top, 0)
        #
        shape_x = max(axis_x_right, im2.shape[1]) - min(axis_x_left, 0)
        #
        print('shape y')
        print(shape_y)
        #
        print('shape x')
        print(shape_x)
        #
        warp_im1_scaled = np.zeros((shape_y, shape_x, 3))
        #
        im2_scaled = np.zeros(warp_im1_scaled.shape)
        #
        im2_mask = np.where(im2 > 0)
        im2_scaled[im2_mask[0] - axis_y_top, im2_mask[1] - axis_x_left, im2_mask[2]] = im2[im2_mask]
        # print('im2_scaled')
        # print(im2_scaled)
        #
        im1_warp_mask = np.where(warp_im1 > 0)
        warp_im1_scaled[im1_warp_mask] = warp_im1[im1_warp_mask]
        # print('warp_im1_scaled')
        # print(warp_im1_scaled)
        #
        return warp_im1_scaled, im2_scaled

def imageStitching(img1, wrap_img2):
        panoImg = np.maximum(img1, wrap_img2)
        #
        panoImg = np.uint8(panoImg)
        return panoImg

if __name__ == '__main__':
        print('my_homography')
        #downSampleRate = 4
        image1 = cv2.imread('incline_L.png')
        image2 = cv2.imread('incline_R.png')
        im1 = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)
        im2 = cv2.cvtColor(image2, cv2.COLOR_BGR2RGB)
        #im1 = im1[::downSampleRate, ::downSampleRate, :]  # downSample because the memory problems
        #im2 = im2[::downSampleRate, ::downSampleRate, :]  # downSample because the memory problems

        H2to1 = np.array([[1.69424090e-03,  1.92939042e-05,  9.98620205e-01],
                   [-2.63154587e-04,  2.48851693e-03, -5.23534795e-02],
                   [-1.14541269e-06,  1.20477243e-07,  2.76877412e-03]])

        # part 2.3
        H_trans, out_size, axis_arr = Translation(im1, H2to1)  # not in HW

        warp_im1 = warpH(im1, H_trans, out_size)
        plt.figure(2)
        plt.imshow(warp_im1)
        plt.show()

        warp_im1_scaled,im2_scaled = getScaled(im2, warp_im1, axis_arr)
        plt.imshow(warp_im1_scaled)
        plt.imshow(im2_scaled)
        panoramaTest = imageStitching(im2_scaled, warp_im1_scaled)
        plt.figure(3)
        plt.imshow(panoramaTest)
        plt.show()